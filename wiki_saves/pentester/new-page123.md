---
title: NewPage123
description: 
published: true
date: 2020-10-27T18:10:17.916Z
tags: 
editor: undefined
dateCreated: 2020-10-27T18:02:46.809Z
---

Kali Linux étant basé sur Débian, les notions ci-dessous vous servirons pour maîtriser votre système. Linux Basics /en/pentester/linuxbasics er

Vous aurez aussi besoin de maîtriser ces notions pour votre vie professionnelle car Linux est trés présent en entreprise, notamment pour les serveurs d'infrastructure.

**Linux ou GNU/Linux** est une famille de systèmes d'exploitation open source de type Unix fondé sur le noyau **Linux**, créé en **1991** par **Linus Torvalds**. De nombreuses distributions **GNU/Linux** ont depuis vu le jour et constituent un important vecteur de popularisation du mouvement du logiciel libre. 

Source : https://fr.wikipedia.org/wiki/Linux

![ubuntu-linux.png](/uploads/linux_basics/ubuntu-linux.png){.align-center}

# Liste des principales distributions

1) Ubuntu https://ubuntu.com/
2) RedHat https://www.redhat.com/fr
3) Debian https://www.debian.org/
4) CentOS https://www.centos.org/
5) Kali Linux https://www.kali.org/
6) Mint https://www.linuxmint.com/
7) ArchLinux https://archlinux.fr/
8) Manjaro https://manjaro.org/
9) Tails https://tails.boum.org/
10) Fedora https://getfedora.org/fr/

# Système de fichier Linux

Kali Linux adhère à la norme de hiérarchie des systèmes de fichiers **FHS**, qui fournit une arborescence universelle pour tous les utilisateurs Linux. 

`/` est le répertoire racine, tous les autres répertoires descendent de cette arborescence mère. Sous Linux, tout est fichier dépendant de cette arborescence. Il en va de même pour les périphériques amovibles.

Contrairement à Windows, un périphérique externe **CD-ROM** ne sera pas monté sur une "*lettre de partition*", mais dans le répertoire **/mnt/cdrom**.

Les répertoires principaux sont:

`/bin` - Contient les binaires fondamentaux à la gestion de Linux (*ls, cd, cat, etc.*).
`/sbin` - Contient les binaires du système (*fdisk, mkfs, sysctl, etc.*).
`/etc` - Fichiers de configuration.
`/tmp` - Fichiers temporaires (*généralement supprimés au démarrage*).
`/usr/bin` - Applications (*apt, ncat, nmap, etc.*).
`/usr/share` - Prise en charge des applications et fichiers de données.
`/home` Contient les répertoires des utilisateurs du système.
`/lost+found` Répertoire des fichiers perdus qui, du fait d’erreur disque, se retrouvent sans chemin d’accès.

Il existe de nombreux autres répertoires, la plupart desquels vous aurez rarement besoin d'utiliser, mais notez qu'une bonne connaissance de la disposition du système de fichiers Linux augmentera votre efficacité et votre rapidité.

# Le terminal

Un terminal est un programme d'invite de commandes dans une interface graphique. Il permet d'entrer des instructions plus rapides que des manipulations demandant beaucoup de clics de souris dans une interface graphique. Il permet également l'envoi d'instructions à distance.

![vmware_ihjzulm3fj.png](/uploads/linux_basics/vmware_ihjzulm3fj.png){.align-center}

Pour ouvrir un terminal il existe plusieurs options :

1) Graphique :

Sous Kali Linux, il existe un raccourci dans la barre des tâches en haut à gauche :

![vmware_rbzztwcnxc.png](/uploads/linux_basics/vmware_rbzztwcnxc.png){.align-center}

Vous pouvez également le retrouver dans le menu des programmes toujours en haut à gauche ou via la touche `windows` de vore clavier.

![vmware_t15ipa9pav.png](/uploads/linux_basics/vmware_t15ipa9pav.png){.align-center}

Il est possible de lancer un terminal avec le lien d'exécution dans le répertoire courant avec `Clic droit + Ouvrir un terminal ici`.

![vmware_twxezbuuhm.png](/uploads/linux_basics/vmware_twxezbuuhm.png){.align-center}

2) Raccourci :

Sous Kali Linux vous pouvez ouvrir un terminal avec la combinaison `Ctrl + Shift + T`.

> Pour exécuter une commande, il suffit de la saisir et d'appuyer sur `Entrer`.
{.is-info}

![vmware_gaxq86m5aj.png](/uploads/linux_basics/vmware_gaxq86m5aj.png){.align-center}

> **Remarque** : Le **copier/coller** est différent des autres environnements : 
> 
> **Copier** : `Ctrl + Shift + C`
>
> **Coller** : `Ctrl + Shift + V`
{.is-warning}

> Pour interrompre une commande en cours d'exécution : `Ctrl + C`
> {.is-danger}

> **Complétion automatique** : Le terminal est capable de compléter vos instructions, chemins ou noms automatiquement en fonction du début de vos commandes.
{.is-info}

1x `TAB` complète automatiquement l'instruction. Si plusieurs possibilités de complétion, le terminal arrêtera sa complétion au caractère précédent les choix multiples.

2x `TAB` affiche toutes les possibilités de complétions en cas de choix multiples.

Dans notre exemple, en renseignant la commande incomplète `apt-get` et en appuyant 2x sur `TAB`, nous obtenons les commandes complètes possibles :

![dw0azoptqo.gif](/uploads/linux_basics/dw0azoptqo.gif){.align-center}

Nous pouvons également affiner la complétion automatique au fur et à mesure de notre commande pour ne garder qu'une seule complétion possible :

![1nn8isgz25.gif](/uploads/linux_basics/1nn8isgz25.gif){.align-center}

La complétion fonctionne également pour les noms de fichiers/répertoires :

![tnlmiljxvl.gif](/uploads/linux_basics/tnlmiljxvl.gif){.align-center}

## Les commandes

Une commande est une ligne d'instruction à exécuter.

![vmware_f993pqxszv.png](/uploads/linux_basics/vmware_f993pqxszv.png){.align-center}

> **Attention** : Lors de la **copie/colle** de plusieurs lignes d'instructions depuis une source externe (*ex: web*), le saut de ligne sera également copié et interprété comme un `Entrer`, exécutant la ligne en question.
{.is-warning}

```
cd Bureau
mkdir Nouveau_Dossier
cd Nouveau_Dossier
```

L'ensemble d'instrutions ci-dessus collé dans un terminal sera lu comme :

```
cd Bureau`[Entrer]`
mkdir Nouveau_Dossier`[Entrer]`
cd Nouveau_Dossier
```

Les lignes suivantes seront donc exécutées dès le collage dans le terminal :

```
cd Bureau
mkdir Nouveau_Dossier
```

Ne laissant plus que cette commande non exécutée :

```
cd Nouveau_Dossier
```

## Appel programme

Tout programme peut être appelé comme s'il l'était avec un double clic depuis le menu principal, qu'il soit graphique ou en ligne de commande. 

Pour se faire, il suffit d'entrer son nom :

![ztguh95kxh.gif](/uploads/linux_basics/ztguh95kxh.gif){.align-center}
![kcsnwaqzay.gif](/uploads/linux_basics/kcsnwaqzay.gif){.align-center}

Lors de l'appel d'un programme, la console devient l'instance père. Tuer le père c'est tuer le processus, donc le programme.

> **Remarque** : La console est alors liée au programme appelé et lui est exclusivement consacrée. Il n'est plus possible de rentrer de nouvelles commandes dans cette instance avant la fin du programme.
{.is-warning}

> Un moyen de contournement consiste à lancer notre programme depuis un processus fils. La console père créé alors un processus fils qui à son tour lance notre programme.
{.is-info}

L'opérateur `&` permet de lancer simultanément deux commandes dont la première sera lancée en arrière plan (*depuis un processus fils*). (*cf.Fork*)

`[Commande_1] & [Commande_2]`

En ne renseignant rien derrière `&`, il est alors possible d'entrer d'autres commandes depuis la même instance de terminal :

```
[Commande] &
```

![vmware_nmvg8m6ck4.png](/uploads/linux_basics/vmware_nmvg8m6ck4.png){.align-center}

Le terminal père renvoie alors le PID (*process ID*) du processus fils. Si on liste les processus, on retrouve bien notre programme :

![vmware_wkrcgkgmow.png](/uploads/linux_basics/vmware_wkrcgkgmow.png){.align-center}
> 
> **Remarque** : Un fils ne peut pas vivre sans père (*sauf zombie*), il est possible de tuer le fils sans tuer le père, mais la mort du père implique la mort du fils, et donc de notre programme.
{.is-warning}

## Entrées/Sorties

Un terminal dispose d'une **entrée standard**, d'une **sortie standard**, et d'une **sortie d'erreur standard**, aussi connues sous le nom de `stdin`, `stdout`, `stderr`. 

Par défaut, `stdin` représente le clavier, `stdout` l'écran et `stderr` la sortie des messages d'erreur vers l'écran.

![winword_pfoewlrsy8.png](/uploads/linux_basics/winword_pfoewlrsy8.png){.align-center}

À chaque entrée/sortie est associée un numéro appelé **descripteur de fichier** : 

![firefox_ulkjlz6wff.png](/uploads/linux_basics/firefox_ulkjlz6wff.png){.align-center}

Comme vous vous en doutez, il est évidemment possible de modifier les associations et donc de rediriger les différentes **entrées/sorties** vers ce qui nous intéresse.

## Redirections

Les redirections permettent simplement, de rediriger un des trois descripteurs de fichier ci-dessus vers à peu près tout ce que vous voulez.

1) Sorties :

`[Source]>[Destination]` Redirige le résultat d'une commande avec écrasement vers autre chose.
`[Destination]<[Source]` Redirige autre chose vers une commande avec écrasement.

2) Entrées :

`[Source]>>[Destination]` Redirige le résultat d'une commande avec ajout vers autre chose.
`[Destination]<<[Source]` Redirige autre chose vers une commande avec ajout.

### Les sorties

Dans notre exemple, nous utiliserons la commande `ls` permettant de lister le contenu d'un répertoire. Cette commande s'exécute dans le répertoire courant de notre terminal soit : `~/Bureau/Archive` et liste donc les éléments présents dans le répertoire `Archive` présent sur le Bureau.

![vmware_tpxajskjnu.png](/uploads/linux_basics/vmware_tpxajskjnu.png){.align-center}
![vmware_lxsudygwln.png](/uploads/linux_basics/vmware_lxsudygwln.png){.align-center}

Nous pouvons rediriger la sortie standard de notre console (*ce qui nous est affiché à l'écran*) vers un fichier pour garder une trace de notre résultat :

```
[Commande] > [Fichier]
```

![vmware_nue2rjhh2q.png](/uploads/linux_basics/vmware_nue2rjhh2q.png){.align-center}

> **Attention** : Utiliser l'opérateur `>` écrase et remplace une destination par votre source. Si la destination existe déjà, son contenu actuel sera perdu !
{.is-danger}

![vmware_5yzlbbxcmu.png](/uploads/linux_basics/vmware_5yzlbbxcmu.png){.align-center}

Notre nouveau fichier `resultat` contient ce que nous a renvoyé notre commande, à savoir la liste des éléments présents dans le répertoire `/home/capuche/Bureau/Archive` :

![vmware_gzvaahkvbg.png](/uploads/linux_basics/vmware_gzvaahkvbg.png){.align-center}

Il peut également être intéressant de sauvegarder dans un fichier les éventuelles erreurs que pourrait nous renvoyer notre commande. Il est alors plus facile de corriger les problèmes et d'en garder une trace.

> **Rappel** : Souvenez vous, la `sortie d'erreur standard` ou `stderr` correspond au descripteur de fichier n° `2`.
{.is-info}

Nous pouvons alors rediriger les erreurs comme ceci : `[Commande] 2> [Destination]`.

Dans notre exemple, nous entrons une commande qui n'existe pas. Le terminal nous indique donc sur notre écran (*sortie d'erreur standard*) que celle-ci est inconnue :

[En cours]


## Codes retour

A la fin de l'exécution d'un programme ou d'une instruction, ceux-ci retournent un code d'exécution.

> Code `0` => Succès
{.is-success}

> Code `≠ 0` => Echec, code erreur.
{.is-danger}

Pour connaitre le code retourné par l'instruction précédente et donc savoir si c'est un succès ou un échec, utilisez la commande : `echo $?`. Dans notre cas, un succès.

![vmware_qiidkw6kow.png](/uploads/linux_basics/vmware_qiidkw6kow.png){.align-center}
# Commandes fondamentales
## man (*Manuel de commandes*)

> C'est certainement la commande la plus importante lorsque l'on débute !
{.is-success}

La plupart des programmes exécutables destinés à la ligne de commande Linux fournissent un élément formel de documentation souvent appelée manuel ou pages de manuel. Un programme spécial appelé `man` est utilisé pour afficher ces pages. Les pages de manuel ont généralement un nom, un synopsis, une description de la commande, les options, paramètres ou commutateurs correspondants. Regardons la page de manuel pour la commande **nmap**:

```
man [commande]
```

![vmware_kjoc3neft1.png](/uploads/linux_basics/vmware_kjoc3neft1.png){.align-center}

Vous obtenez alors tout le manuel pour la commande correspondante :

![vmware_q3ptpnhgan.png](/uploads/linux_basics/vmware_q3ptpnhgan.png){.align-center}

Pour quitter le manuel, il suffit d'appuyer sur la touche `Q`.

![vmware_gulexrd9o6.png](/uploads/linux_basics/vmware_gulexrd9o6.png){.align-center}

> Info : Les pages de manuel sont téléchargées en local lors de l'installation d'un outils. Vous pouvez donc y accéder même sans connexion à Internet. 
{.is-info}

Les pages de manuel contiennent non seulement des informations sur les commandes utilisateur, mais également une documentation concernant les commandes d'administration système, interfaces de programmation, etc. Le contenu du manuel est divisé en sections numérotées comme suit:

> 1) Commandes utilisateur.
> 2) Interfaces de programmation pour les appels système du noyau.
> 3) Interfaces de programmation vers la bibliothèque C.
> 4) Fichiers spéciaux tels que les nœuds de périphérique et les pilotes.
> 5) Formats de fichiers.
> 6) Jeux et divertissements.
> 7) Divers.
> 8) Commandes d'administration système.

Pour déterminer la section manuelle appropriée, effectuez simplement une recherche par mot clé. Par exemple, disons que nous souhaitons en savoir un peu plus sur le format de fichier de /etc/passwd.

```
man passwd
```

![vmware_aozsb2nsuq.png](/uploads/linux_basics/vmware_aozsb2nsuq.png){.align-center}
La commande nous retourne l'affichage des informations concernant la commande passwd via la section 1 du manuel ce qui n'est pas ce qui nous intéresse ici.

> Cependant, si nous utilisons l'option **-k** avec **man**, nous pouvons effectuer une recherche par mot-clé :
{.is-success}

```
man -k passwd
```

![vmware_2kaptelvnh.png](/uploads/linux_basics/vmware_2kaptelvnh.png){.align-center}

> Info : **man** accepte parfaitement les expressions régulières pour un tri plus fin.
{.is-info}

```
man -k '^passwd$'
```

![vmware_2cjk4kp6wi.png](/uploads/linux_basics/vmware_2cjk4kp6wi.png){.align-center}

Dans la commande ci-dessus, l'expression régulière est entourée d'un signe caret (^) et d'un signe dollar ($), correspondants respectivement à la sélection de la ligne entière tout en  évitant les correspondances de sous-chaînes. Nous pouvons maintenant consulter le manuel exact de passwd qui nous intéresse :

```
man 5 passwd
```

![vmware_05jceyywky.png](/uploads/linux_basics/vmware_05jceyywky.png){.align-center}

## pwd (Position)

Lorsque l’on se déplace dans les répertoires, il peut arriver de se perdre ou que votre terminal bash n’affiche que le «*nom court*» du répertoire où vous vous trouvez. Le nom court ne comprend pas le chemin complet. Il peut arriver qu’un même nom court corresponde à plusieurs répertoires bien distincts, que seuls les chemins complets permettent de distinguer. C’est par exemple le cas du nom court "**bin**", que l’on trouve en ***/bin*** et en ***/usr/local/bin***. 

La solution pour connaître le chemin du répertoire où l’on se trouve est d’utiliser la commande :

```
pwd
```

![vmware_g3vlwpe5xg.png](/uploads/linux_basics/vmware_g3vlwpe5xg.png){.align-center}

## whoami (Qui suis-je ?)

Lors d'élévation de privilège ou d'opérations sur des comptes utilisateurs, il peut parfois être nécessaire de vérifier le compte executant les instructions dans notre terminal.

```
whoami
```

![vmware_asbkcmfb6p.png](/uploads/linux_basics/vmware_asbkcmfb6p.png){.align-center}

## su (Changement de session utilisateur)

La commande su dans un terminal ou une console permet de devenir un autre utilisateur pour la durée d'une session ou, si on n'indique aucun user, de prendre les privilèges root. 

> **ATTENTION** : ROOT est un super-utilisateur, ce n'est pas un compte lambda mais un compte système omnipotent ! Il n'y a pas de limite à ses privilèges ni à ses actions (*même si cela implique sa propre destruction ou celle de votre machine*). Il n'y a pas d'avertissement ni de retour en arrière possible. Maniez ROOT avec précautions !
{.is-danger}

```
su [utilisateur]
```

![vmware_gpyboiz5gq.png](/uploads/linux_basics/vmware_gpyboiz5gq.png){.align-center}

Pour invoquer le compte ROOT :

```
sudo su
```

![vmware_uu7lxki68k.png](/uploads/linux_basics/vmware_uu7lxki68k.png){.align-center}

> Toute commande exécutée à partir de là, le sera avec le niveau de privilège ROOT jusqu'à la fermeture du terminal ou changement d'utilisateur.
{.is-warning}

## sudo (Privilège administrateur)

Les actions que l'on peut être amené à effectuer sur son système relèvent de deux types: 

- L'utilisation courante (*lire ses mails, naviguer sur Internet, etc*),
- L'administration (*installation de logiciels et configuration avancée*). 

L'utilisation courante ne demande pas de privilèges particuliers.

Par contre pour les tâches d'administration, qui pourraient endommager le système en cas d'erreur, des droits spécifiques sont requis: les droits de super utilisateur.

Pour lancer une telle tâche ou commande, il vous faut la faire précédé de la commande sudo :

```
sudo [commande]
```

![vmware_xcbkeoeezq.png](/uploads/linux_basics/vmware_xcbkeoeezq.png){.align-center}

> Remarque : l'élévation de privilège n'est alors valable que pour la commande en cours.
{.is-success}

## cd (Déplacement)

Linux n'utilise pas de lettres de lecteur comme Windows. Au lieu de cela, tous les fichiers, dossiers et périphériques sont des enfants du répertoire racine, représenté par le caractère «**/**». 

Nous pouvons utiliser la commande **cd** suivie d'un chemin d'accès au répertoire spécifié pour nous déplacer dans l'arborescence. 

```
cd [chemin]
```

![vmware_udxneikg9c.png](/uploads/linux_basics/vmware_udxneikg9c.png){.align-center}

Pour remonter d'un cran dans l'orborescence vous pouvez utiliser la commande :

```
cd ..
```

![vmware_0tvyxxgsxn.png](/uploads/linux_basics/vmware_0tvyxxgsxn.png){.align-center}

> Remarque : vous pouvez l'utiliser jusqu'à remonter jusqu'à la racine du système.
{.is-info}

Pour remonter directement à la racine du système vous pouvez utiliser la commande :

```
cd /
```

![vmware_1hctuorusn.png](/uploads/linux_basics/vmware_1hctuorusn.png){.align-center}

Pour retourner directement dans le répertoire personnel de votre utilisateur :

```
cd ~
```

![vmware_nkorv0orzj.png](/uploads/linux_basics/vmware_nkorv0orzj.png){.align-center}

## ls (Listage)

La commande **ls** et ses très nombreuses options vous permettront d’obtenir beaucoup d’informations sur les fichiers présents dans un répertoire.

> Remarque : Sous linux tout élément est un fichier découlant d'une arborescence mère, il pourra être modifié et sera affiché comme tel.
{.is-warning}

Pour un affichage brute du répertoire courant :

`ls`

Pour un affichage brute d'un répertoire donné :

`ls [chemin]`

![vmware_tfsmecqnzb.png](/uploads/linux_basics/vmware_tfsmecqnzb.png){.align-center}

Nous pouvons ici lister les fichiers et répertoires contenus dans **/usr/share/wordlists**, dont le très célebre **RockYou.txt** contenant la liste des mots de passe les plus utilisés.

Mais rien ne nous permets de distinguer les fichiers des dossiers si ce n'est la couleur.

Pour obtenir les attributs des éléments, on utilise l'option `-l` :

`ls -l`

![vmware_yzobyourfk.png](/uploads/linux_basics/vmware_yzobyourfk.png){.align-center}


On obtient une vu beaucoup plus détaillée de notre répertoire :

### Taille totale
Ci-dessous la taille total du répertoire en blocs de 512 octets.

![vmware_jgsobmgfku.png](/uploads/linux_basics/vmware_jgsobmgfku.png){.align-center}

### Types de fichiers

Le premier élément de chaque ligne correspond au type d'élément. 

> ![vmware_xxbzxvonth.png](/uploads/linux_basics/vmware_xxbzxvonth.png){.align-center}
> `l` indique un lien virtuel vers un autre répertoire (*link*).


> ![vmware_aaxc5jzcou.png](/uploads/linux_basics/vmware_aaxc5jzcou.png){.align-center}
> `d` indique que l'élément est un dossier (*directory*).

> ![vmware_vzzxq3whxq.png](/uploads/linux_basics/vmware_vzzxq3whxq.png){.align-center}
> `-` indique que l'élément est un fichier.

### Permissions d'accès

Le champ `rwxrwxrwx` indique les permissions de lecture `r` (*read*), d'écriture `w` (*write*) et d'exécution `x` (*execute*).

![vmware_k0m4pyqr96.png](/uploads/linux_basics/vmware_k0m4pyqr96.png){.align-center}

Les droits d'un élément se divisent en 3x3 niveaux (*rwx*), soit `rwxrwxrwx` correspondants au propriétaire, au groupe, aux autres utilisateurs et doivent donc être lu par paquets de 3.

- Premier triplet : `rwx......` : **Le propriétaire**.

![vmware_xy37a5dutp.png](/uploads/linux_basics/vmware_xy37a5dutp.png){.align-center}

Concerne les droits d’accès du **propriétaire**. Dans notre cas : `rw-` 

Ce dernier possède un accès en lecture `r` et écriture `w`. La lettre `x` est absente, le fichier ne peut donc pas être éxécuté même par son propriétaire.

- Deuxième triplet : `...rwx...` : **Le groupe**.

![vmware_rpkri58mxs.png](/uploads/linux_basics/vmware_rpkri58mxs.png){.align-center}

Concerne les droits d’accès du **groupe**. Dans notre cas : `r--` 

Ce dernier possède un accès en lecture `r`. La lettre `w` est absente, le fichier ne peut pas être modifié par une autre personne que son propriétaire, même faisant partie du même groupe que lui. La lettre `x` est absente, le fichier ne peut donc pas être éxécuté par le groupe.

- Dernier triplet : `......rwx` : **Les autres utilisateurs**.

![vmware_szoob7yfmm.png](/uploads/linux_basics/vmware_szoob7yfmm.png){.align-center}

Concerne les droits d’accès **des autres utilisateurs**. Dans notre cas : `r--` 

Idem que les droits de groupe, lecture permise pour tous, mais pas de modification ni d'exécution.

Résumé des droits sur notre fichier :

> **Lecture** `r` : *Tout le monde*
> **Écriture** `w` : *Le propriétaire*
> **Exécution** `x` : *Personne*

### Liens physiques

Indique le nombre de lien(s) dirigeant vers l'élément en question. Un seul et même élément peut être accédé de plusieurs chemins via un lien afin de gagner en espace de stockage.

![vmware_j1pzznhmfw.png](/uploads/linux_basics/vmware_j1pzznhmfw.png){.align-center}

Dans notre cas, `2` chemins mènent au même fichier. Si le nombre est `1`, alors il existe un chemin unique, celui sur lequel vous êtes.

### Propriétaire et groupe

![vmware_c3wodjinkf.png](/uploads/linux_basics/vmware_c3wodjinkf.png){.align-center}

Le fichier appartient donc à ROOT et au groupe du même nom. 

### Taille du fichier

![vmware_5knvo1ll26.png](/uploads/linux_basics/vmware_5knvo1ll26.png){.align-center}

Donne la taille en octets du fichier. `53357329` **octets** soit environ `53.36` **Mo** dans sa version archive compressée **.gz**.

> Remarque, il est possible d'ajouter l'option `-h` (*human readable*) pour obtenir les valeurs de façon plus compréhensible.
{.is-warning}

Avec notre nouvelle option : `ls -lh`.

![4mjvqt0dbw.png](/uploads/linux_basics/4mjvqt0dbw.png){.align-center}

### Date de modification

![vmware_qvefbv6jlg.png](/uploads/linux_basics/vmware_qvefbv6jlg.png)

Date de dernière modification : `17 Juillet 2019`.

### Nom de l'élément

![vmware_koupvlmpbx.png](/uploads/linux_basics/vmware_koupvlmpbx.png){.align-center}

Le fichier se nomme `rockyou.txt.gz`.


---

> Sous linux il existe des fichiers qui ne sont d'ordinaire pas pertinants à afficher et sont donc cachés pour des raisons d'ergonomie et de sécurité (*les fichiers temporaires ou d'historique de terminale par exemple*). 
{.is-warning}

Ces fichiers cachés sont du format `.[nom_du_fichier]`. 
Ces fichiers nous intéressent et peuvent être affichés avec l'option `-a` :

![vmware_5jigt9bynh.png](/uploads/linux_basics/vmware_5jigt9bynh.png){.align-center}

On peut voir ici l'apparition du fichier `.je_suis_un_ninja`, invisible jusque là avec la simple commande `ls`.

> La commande `ls` accepte le combo d'options. 
> Retenez donc certainement une des commandes les plus utilisées sous linux : `ls -hal`.
{.is-success}

![vmware_nqoc4vo1pb.png](/uploads/linux_basics/vmware_nqoc4vo1pb.png){.align-center}

On a donc un listing détaillé de **TOUS** les éléments d'un répertoires avec leurs caractéristiques.

> Remarque :
> - Le répertoire `.` correspond au répertoire courant.
> - Le répertoire `..` correspond au répertoire parent (*n-1*).
{.is-warning}

> **Remarque** : Ce n'est qu'une toute petite partie de ce que peut offrir `ls` ! Je vous invite à vous familiariser avec cet outil indispensable et avec ses nombreuses options.
{.is-warning}

Entre autres :

- Listez les fichiers en triant par date : `ls -lt`.
- Inverser l’ordre du tri afin d’avoir la date de modification la plus récente en bas : `ls -lrt`.
- Ajoutez de la couleur : `ls -l –color=auto`.
- Listez seulement les répertoires : `ls -ld */`.
- Listez récursivement le contenu des répertoires : `ls -R`.
- Affichez un fichier par ligne : `ls -1`.
- Affichez le numero d’inode : `ls -i`.
- Affichez l’UID et le GID : `ls -n`.

## chmod (Gestion des droits)

Linux permet de spécifier les droits qu’ont les utilisateurs sur un fichier. Cette spécificité d’UNIX sur la méthode de fixation des permissions sur un fichier assure une très grande sécurité et une très grande souplesse.

C’est donc la commande `chmod` qui permet de modifier ces permissions qu’ont les utilisateurs sur le fichier. Évidemment, seul le propriétaire du fichier a le pouvoir de modifier ces permissions (*à part bien sur le superutilisateur “root” qui peut faire absolulement tout ce que bon lui semble...*).

### Synthaxe alphanumérique

`u` Fait référence au **propriétaire** du fichier.
`g` Fait référence au **groupe d'utilisateurs** possèdant le fichier.
`o` Fait référence au **autres** utilisateurs.
`a` Fait référence à **tous** les utilisateurs.

`+` Utilisé pour **ajouter** une permission.
`-` Utilisé pour **retirer** une permission.

`r` Désigne les droits en **lecture** (*read*).
`w` Désigne les droits d'**écriture** (*write*).
`x` Désigne les droits d'**exécution** (*exec*).

`-R` Option de récursivité pour les sous-dossiers.

Commande de modification : 

`chmod [Utilisateur(s)][Action][Droit(s)] [Nom_fichier]`

ou

`chmod u=[Droits_rwx],g=[Droits_rwx],o=[Droits_rwx] [Nom_fichier]`

Dans notre cas un fichier avec les droits suivants :

![vmware_hdkq5kmlrx.png](/uploads/linux_basics/vmware_hdkq5kmlrx.png){.align-center}

> **Propriétaire** (rw-) : Lecture + écriture. 
> **Groupe** (r--) : Lecture. 
> **Autres** (---) : Aucun. 

Nous donnons à tous le droit de lire ce fichier mais pas de l'éditer :

![vmware_4vceerkdez.png](/uploads/linux_basics/vmware_4vceerkdez.png){.align-center}

ou

![vmware_uqwugmc3nt.png](/uploads/linux_basics/vmware_uqwugmc3nt.png){.align-center}

Nous pouvons voir les nouveaux droits appliqués :

![vmware_mxziplxg8i.png](/uploads/linux_basics/vmware_mxziplxg8i.png){.align-center}

> **Propriétaire** (rw-) : Lecture + écriture. 
> **Groupe** (r--) : Lecture. 
> **Autres** (r--) : Lecture. 

### Synthaxe binaire/octale

Il est tout à fait possible d'indiquer les droits d'accès sur un fichier au format octale. Les triplets sont alors vu comme des systèmes binaires, rendant la commande `chmod` plus concise.

`rwx` est alors vu comme le système binaire `111`. Pour la traduction en valeur octale, il suffit d'additionner les bits actifs à `1` selon le système binaire classique `421`.

Pour `r-x` ont a `101` soit `4+0+1` soit `5`.

Commande octale : `chmod [Valeur_octale] [Nom_Fichier]`

![firefox_lu1zma5u9q.png](/uploads/linux_basics/firefox_lu1zma5u9q.png){.align-center}

Ainsi, la même commande que précédent pourra se traduire par :

> **Propriétaire** (rw-) : Lecture + écriture => 110 => 6
> **Groupe** (r--) : Lecture => 100 => 4
> **Autres** (r--) : Lecture => 100 => 4

Soit `644`.

![vmware_ycftesp6af.png](/uploads/linux_basics/vmware_ycftesp6af.png){.align-center}

Valeurs utiles :

`644` - Lecture, écriture pour le propriétaire / Lecture pour les autres.
`666` - Lecture, écriture pour tout le monde.
`700` - Lecture, écriture, execution juste pour le propriétaire.
`705` - Le propriétaire à tous les droits / Le groupe aucun / Les autres lire et executer.
`755` - Le propriétaire à tous les droits / Les autres lire et executer.
`764` - Tous droits pour le propriétaire / Lecture, écriture pour le groupe / Lecture seule pour les autres.
`774` - Tous les droits pour le propriétaire et le groupe / Lecture seule pour les autres.
`775` - Tous les droits pour le propriétaire et le groupe / Lecture et exécution pour les autres.
`777` - Tous les droits pour tous.

> Attention : Les valeurs `666` ou encore pire `777` sont à éviter au maximum !
{.is-danger}

## touch (Créer un fichier)

La commande **touch** sans aucune option crée un nouveau fichier. Si le fichier existe, la commande touch mettra à jour l’accès et la modification à l’heure actuelle sans changer son contenu :

`touch [nom_de_fichier].[extension]`

![vmware_mgkb3ei5ij.png](/uploads/linux_basics/vmware_mgkb3ei5ij.png){.align-center}

> Remarque : Il est également possible de créer plusieurs fichiers en utilisant une seule commande touch. Pour ce faire, il faut spécifier les noms des fichiers avec des espaces entre eux.
{.is-warning}

`touch [nom_fichier_1].[extension] [nom_fichier_2].[extension] [nom_fichier_3].[extension]`

![vmware_s21xug7oda.png](/uploads/linux_basics/vmware_s21xug7oda.png){.align-center}

![vmware_hspz76ycxu.png](/uploads/linux_basics/vmware_hspz76ycxu.png){.align-center}

Vous pouvez générer automatiquement des noms de fichiers en utilisant des accolades tout en créant plusieurs fichiers :

![vmware_ht2gb0nfjn.png](/uploads/linux_basics/vmware_ht2gb0nfjn.png){.align-center}

## cat / more (Voir un fichier)

Il est parfois nécessaire de lire un fichier sans pouvoir autant avoir à le modifier.

> Remarque : Il peut parfois être nécessaire de lancer les commandes en mode `sudo` en fonction des droits d'accès sur le fichier à lire.
{.is-warning}

Pour cela la commande `cat` est très utile : `cat [chemin\nom_fichier]`

![vmware_k0hehuukvx.png](/uploads/linux_basics/vmware_k0hehuukvx.png){.align-center}

> Il est possible d'afficher les numéros de ligne avec l'option `-n` : `cat -n [chemin\nom_fichier]`
{.is-info}

Pour visualiser de gros fichiers, comme un dictionnaire d'attaque, il peut être intéressant de les afficher pages par pages : `more [chemin\nom_fichier]`

![vmware_etv8ydew2j.png](/uploads/linux_basics/vmware_etv8ydew2j.png){.align-center}

![vmware_y7caugi9vq.png](/uploads/linux_basics/vmware_y7caugi9vq.png){.align-center}

Vous pouvez passer à la page suivante avec `espace`, descendre ligne par ligne avec `entrer`, vous déplacer librement avec les `flèches directionnelles` et quitter avec `q`.
## vi / nano / emacs (Éditer un fichier)

`vi` date des années 70 ... autant dire que cet éditeur a de la bouteille. Son apparence fruste et archaïque en font un éditeur mal aimé mais extrêment puissant. C’est dans les moments critiques où rien ne fonctionne, où tout va mal, que vi développe tout son potentiel (*aka Kernel Panic*). Il sera toujours présent même sur les distributions les plus exotiques à des niveaux extrêment bas puisque embarqué dans les noyaux les plus basiques de Linux. **Bref, il sauve des vies**.

![vmware_x7jnk2s5qs.png](/uploads/linux_basics/vmware_x7jnk2s5qs.png){.align-center}

`vi` offre deux modes de fonctionnement : 

> 1) Le mode commande 
> 2) Le mode insertion.

Au démarrage il est en mode commande, qui permet de déplacer le curseur, de parcourir le document et de copier-coller. On le quitte, en utilisant une commande d'insertion ou de modification.

Touche `[ESC]` ou `a` (*append*).

![vmware_ywlxjz2mhi.png](/uploads/linux_basics/vmware_ywlxjz2mhi.png){.align-center}

> Remarque : Vi est... brute de fonderie. N'oubliez pas de saisir un retour chariot à la fin de chaque ligne.
{.is-warning}

En mode insertion il est possible de saisir du texte. Appuyer sur la touche `[ESC]` pour revenir en mode commande.

De nombreuses commandes peuvent être préfixées du nombre de répétitions souhaitées, par exemple `5w` avance le curseur de 5 mots (*words*). 

### Les commandes principales

`:w` sauvegarde le contenu du fichier.
`:x` sauvegarde puis quitte vi.
`:wq` sauvegarde puis quitte.
`ZZ` sauvegarde si nécessaire puis quitte.
`:q` quitte vi sans sauvegarder les modifications.
`:e!` ignore les modifications et recharge le fichier (*le point d'exclamation marque l'impératif*).
`:q!` quitte immédiatement, sans rien faire d'autre (*donc sans sauvergarder ni demande de confirmation*).
`:w nom_de_fichier` sauvegarde le fichier sous le nom *nom_de_fichier*.
`:w! nom_de_fichier` remplace le contenu du fichier *nom_de_fichier*.

`[CTRL]f` descend d'une page.
`[CTRL]b` remonte d'une page.
`[CTRL]d` descend d'1/2 page.
`[CTRL]u` remonte d'1/2 page.
`:X` va à la ligne numérotée X.
    
`H` en haut de l'écran
`M` au milieu de l'écran
`L` en bas de l'écran
`h` décale d'un caractère à gauche
`j` descend d'une ligne
`k` monte d'une ligne
`l` décale d'un caractère à droite
`0` au début de la ligne
    
`i` active le mode insertion
`a` active le mode insertion, un caractère après le curseur
`I` insère au début de la ligne
`A` insère à la fin de la ligne
`O` insère une ligne au-dessus du curseur et passe en mode insertion
`o` insère une ligne en dessous du curseur et passe en mode insertion
    
`x` supprime un caractère
`dw` supprime un mot
`dnw` supprime n mots
`dd` supprime une ligne
`ndd` supprime n lignes
    
`Y` copie une ligne
`nY` copie n lignes
`P` colle les lignes avant le curseur
`p` colle les lignes après le curseur
    
`u` annule la dernière modification
`U` annule toutes les modifications effectuées sur la ligne courante
`.` répète les dernières modifications

---

`Nano` est un simple éditeur de texte qui n'offre pas de fantaisie mais qui est plus attrayant que `vi`. Il permet d'éditer simplement et rapidement les fichiers textes, mais certains l'utilisent pour leurs travaux documentaires.

![vmware_zdi6v9uery.png](/uploads/linux_basics/vmware_zdi6v9uery.png){.align-center}

`nano -l nom_du_fichier` Ceci ouvrira le fichier dans une fenêtre d'édition avec l'affichage du numéro de lignes.

Vous pouvez retrouver en bas du terminal un mémo pour les commandes utiles.

![vmware_th8mbekfji.png](/uploads/linux_basics/vmware_th8mbekfji.png){.align-center}

> Le symbole `^` signifie `Ctrl`. Ainsi, pour quitter Nano, il suffit de taper `Ctrl + X`.
{.is-info}

---
`GNU Emacs` est l’une des deux versions les plus populaires de l’éditeur de texte Emacs. Le manuel de GNU Emacs le décrit comme l’incarnation GNU de l’éditeur plein écran avancé, auto-documenté, personnalisable et extensible qu’est Emacs. 

Emacs date de la fin des années 70 et ne cesse d’évoluer depuis, ce qui fait de lui, sans aucun doute possible, l’éditeur le plus puissant au monde. Bien plus qu’un éditeur, emacs est un environnement de travail : édition, programmation, mail, news, shell … bref on peut rester sous emacs sans avoir besoin de quoi que ce soit d’autre.

![vmware_dffzhbatmm.png](/uploads/linux_basics/vmware_dffzhbatmm.png){.align-center}

> **Remarque** : Emacs n'est pas installé par défaut sur Kali Linux, il faudra utiliser la commande `sudo apt-get install emacs` pour l'installer.
{.is-warning}

C'est un outils extrêmement complet et puissant, il dispose de nombreuses fonctions, allant du chiffrement au comparatif de fichiers en passant par un calendrier ou des jeux.

![vmware_vavvvyzmcj.png](/uploads/linux_basics/vmware_vavvvyzmcj.png){.align-center}

Plus lourd que ses homologues, mais un atout majeur si vous l'avez sur votre système.
## cp (Copie)

La commande `cp` vous permet de copier un fichier en le renommant ou non.

`cp [option] [fichier_origine] [fichier_destination]`

ou

`cp [option] [fichier_origine] [répertoire]`

> Attention : Si vous effectuez une copie d’un fichier sur un fichier qui existe dejà, celui-ci sera effacé et remplacé par le nouveau fichier sans avertissement !
{.is-danger}

Pour notre exemple, nous effectuerons le backup d'un fichier utilisateur.

![vmware_iaaxfbwedd.png](/uploads/linux_basics/vmware_iaaxfbwedd.png){.align-center}
![vmware_gs80kujqiy.png](/uploads/linux_basics/vmware_gs80kujqiy.png){.align-center}

Dans notre premier cas, nous effectuons la copie d'un fichier dans le même répertoire en le renommant :

![vmware_l9vil6l9rw.png](/uploads/linux_basics/vmware_l9vil6l9rw.png){.align-center}

Dans notre second cas nous le sauvergardons dans un autre répertoire avec le même nom :

![vmware_hppvz3dzjt.png](/uploads/linux_basics/vmware_hppvz3dzjt.png){.align-center}

Options utiles :

`cp -b` permet comme l’option` -i` de s’assurer que la copie n’écrase pas un fichier existant : le fichier écrasé est sauvegardé, seul le nom du fichier d’origine est modifié et `cp` ajoute un tilde (~) à la fin du nom du fichier.

`cp -l` permet de faire un lien entre le fichier source et sa copie. Ceci signifie que le fichier copié et sa copie partageront physiquement le même espace. Cela permet des gains de place non négligeables. Plus exactement, sur le disque dur le fichier et sa copie seront le même fichier alors qu’avec une copie classique, le disque dur contiendra deux exemplaires du fichier.

`cp -s` permet de faire un lien “symbolique” entre le fichier source et sa copie. Le lien symbolique est un pointeur. Ainsi si nous copions le fichier linux-test avec l’option `-s`, lorsque par exemple nous voudrons éditer le fichier copié, linux éditera en réalité le fichier original.

`cp -p` permet lors de la copie de préserver toutes les informations concernant le fichier comme le propriétaire, le groupe, la date de création.

`cp -r` permet de copier de manière récursive l’ensemble d’un répertoire et de ses
sous-répertoires.

`cp -v` permet d’afficher le nom des fichiers copiés. Utile si par exemple vous copiez
plusieurs fichiers (*à l’aide des occurences `*` et/ou `?`*) et que vous souhaitez voir le bon déroulement de votre “*multicopie*”.

## mv (Déplacer / Rennomer / Écraser un Fichier/Dossier)

> Attention : Tout comme cp, le déplacement d’un fichier sur un fichier qui existe dejà, ou un répertoire sur un répertoire existant entrainera son écrasement sans avertissement !
{.is-danger}

La fonction première de mv consiste à déplacer un fichier : 

`mv [Fichier] [Chemin_nouveau_répertoire]`

Dans notre exemple, nous déplaçons `[Fichier_Utilisateur]` du `[Bureau]` vers `[Documents]` :

![vmware_ef8imkgbll.png](/uploads/linux_basics/vmware_ef8imkgbll.png){.align-center}

Par extension, on peut l'utiliser pour rennomer un fichier ou un dossier en le déplaçant dans le même répertoire mais avec un nom différent :

`mv [Nom_fichier] [Nouveau_Nom]`
ou
`mv [Nom_répertoire] [Nouveau_Nom]`

![vmware_0fmcos47ld.png](/uploads/linux_basics/vmware_0fmcos47ld.png){.align-center}

Options utiles :

`mv -b` (*backup*) va effectuer une sauvegarde des fichiers avant de les déplacer.
`mv -i` (*interactive*) demande pour chaque fichier et chaque répertoire s’il peut ou non déplacer fichiers et répertoires.
`mv -u` (*update*) demande à `mv` de ne pas supprimer le fichier si sa date de modification est la même ou est plus récente que son remplaçant.

## rm (Supprimer un fichier/répertoire)

`rm` permet de supprimer un fichier ou un répertoire.

> Attention : Cette commande est dangereuse et est à manier avec précaution.
{.is-danger}

Pour supprimer un fichier : `rm [nom_fichier]`

![vmware_v0wexxnd5a.png](/uploads/linux_basics/vmware_v0wexxnd5a.png){.align-center}

Pour supprimer avec une demande de confirmation : `rm -i [nom_fichier]`

![vmware_siskwdq6hu.png](/uploads/linux_basics/vmware_siskwdq6hu.png){.align-center}

> **Dangereux** :
> Pour **supprimer un dossier** (*vide ou non*) : `rm -d`
> Pour **supprimer un dossier et tous ses sous-dossier** (*récursif*) : `rm -r`
> Pour **supprimer les éléments protégés** et sans prompt : `rm -f`
{.is-warning}

> **Trés dangereux** :
> Pour détruire un système et tout supprimer (*en tant que root*) : `rm -rf /*`
{.is-danger}

## mkdir (Créer un répertoire)

Pour créer un répertoire, rien de plus simple : `mkdir [Nom_répertoire]`

Dans notre exemple, nous créons le répertoire `NewDossier` dans `/home/capuche/Bureau`.

![vmware_civw9yzjon.png](/uploads/linux_basics/vmware_civw9yzjon.png){.align-center}
![vmware_rwripupoyj.png](/uploads/linux_basics/vmware_rwripupoyj.png){.align-center}

Pour pouvoir créer une arborescence rapidement, utilisez l'option `-p` :

`mkdir -p [Dossier_parent]/[Sous_dossier_1]/.../[Sous_dossier_n]`

![vmware_hkk5zewwfn.png](/uploads/linux_basics/vmware_hkk5zewwfn.png){.align-center}
![vmware_4z3qdu7ule.png](/uploads/linux_basics/vmware_4z3qdu7ule.png){.align-center}
![vmware_g49fttswej.png](/uploads/linux_basics/vmware_g49fttswej.png){.align-center}

## rmdir (Supprimer un répertoire)

> `rmdir` correspond à la commande `rm -d` mais beaucoup plus safe.
{.is-success}

Cette commande ne supprime un répertoire que si celui-ci est vide.

`rmdir [Nom_répertoire]`

![vmware_d2kmmyelmm.png](/uploads/linux_basics/vmware_d2kmmyelmm.png){.align-center}

## find / locate / which (Trouver un fichier)

Pour pouvoir rechercher un fichier, la commande `find` est tout indiquée :

`find [Chemin_racine] -name [nom_fichier]`

Dans notre exemple, nous recherchons le `FichierPerdu` depuis le répertoire racine `/`, donc dans tout notre système.

![vmware_lqy03bjfma.png](/uploads/linux_basics/vmware_lqy03bjfma.png){.align-center}
![nkeivut7sc.gif](/uploads/linux_basics/nkeivut7sc.gif){.align-center}

Il est possible de rechercher un fichier avec des informations incomplètes garce à l'opérateur `*` (*tous*).

Dans notre exemple `FichierPerdu` peut s'écrire `*chierPe*`, l'opérateur `*` acceptant tous les résultats, il comblera le vide avant et après notre expression.

![vmware_yy8cczdrgq.png](/uploads/linux_basics/vmware_yy8cczdrgq.png){.align-center}

Options utiles :

`-type` Filtre un certain type de fichier.
`-exec` Execute une commande avec les éléments trouvés.

---

La commande `locate` a la même mission que `find`. Pourtant vous verrez qu’en utilisant la commande locate, le fichier sera trouvé beaucoup plus rapidement.

`locate` ne va pas chercher le fichier dans toute l’arborescence des répertoires mais va localiser la position du fichier dans une base de données qui contient la liste des fichiers existants. Cette base de données est en général automatiquement générée une fois par jour par le système grâce à une commande appelée `updatedb`.

Pour rechercher un fichier `locate nom_du_fichier`.

Bien que la commande `locate` soit très intéressante, elle ne possède pas la puissance des options de `find`. De plus, si vous créez des fichiers pendant la journée et que vous les recherchez avec la commande `locate`, il n’est pas sûr que la base de donnée ait été remise à jour. `locate` est donc un complément de `find`.

---

La commande `which` vous permet simplement de connaître le chemin d’un exécutable.

`which [nom_executable]`

![vmware_ivv1gaduqy.png](/uploads/linux_basics/vmware_ivv1gaduqy.png){.align-center}

## grep (Trouver texte dans un fichier)

La commande `grep` est un pivot des commandes UNIX. Elle cherche une expression rationnelle dans un ou plusieurs fichiers.

`grep [Expression] [Fichier]`

Dans notre exemple, on recherche l'occurence de l'adresse IP **10.11.1.8** dans un scan nmap.

![vmware_i1ouc0cazk.png](/uploads/linux_basics/vmware_i1ouc0cazk.png){.align-center}

`grep -n [Expression] [Fichier]` permet d'afficher le numéro de ligne pour retrouver plus facilement les occurences dans un fichier. 

![vmware_vsjeauhusc.png](/uploads/linux_basics/vmware_vsjeauhusc.png){.align-center}

`grep -l [Expression] [Chemin]/*` permet d'afficher tous les fichiers d'un répertoire contenant l'expression recherchée.

![vmware_c8gzp1ug8c.png](/uploads/linux_basics/vmware_c8gzp1ug8c.png){.align-center}

`grep -c [Expression] [Fichier]` permet d'afficher le nombre de fois où l'occurence est présente dans un fichier.

## ln (Liens)

Les liens forment un axe central du fonctionnement de linux. Un lien est un type spécial de fichier qui permet à plusieurs noms de fichiers de faire référence au même fichier sur le disque.

Les liens sont utiles si vous souhaitez qu’un fichier apparaisse dans plusieurs répertoires, ou sous un nom différent. Imaginez qu'un fichier fasse quelques megaoctets. Une copie à l’aide `cp` entraînera une perte de place non négligeable alors qu’un lien permettra de limiter l’utilisation de l’espace disque. 

> Un lien garanti que toute modification effectuée sur ce fichier, concernera **toutes** les apparentes « copies » dispersées.
{.is-success}

On doit distinguer deux sortes de liens :

### 1) Les liens en durs 

Ils associent deux ou plusieurs fichiers à un même espace sur le disque, les deux fichiers sont pourtant indépendants. Physiquement, les fichiers sont les mêmes mais virtuellement ils ne le sont pas. 

`ln [Fichier_lié_source] [Nom_fichier]`

![vmware_h5r3cvkarw.png](/uploads/linux_basics/vmware_h5r3cvkarw.png){.align-center}
![vmware_pthpfpbzsf.png](/uploads/linux_basics/vmware_pthpfpbzsf.png){.align-center}

Dans notre cas, le fichier `Lien_CLient` est créé dans le répertoire `~/Bureau` lié au fichier `Client_Secret` dans le répertoire `~/Bureau/Archive`. 

Au niveau de leur existence sous linux, ils sont indépendants. Mais sur le disque, il n’existe qu’un seul fichier, simplement `Lien_CLient` et `Client_Secret` sont sur le même espace (*ou inode*) sur le disque dur lorsqu’on les appelle.

Ainsi si nous modifions le fichier `Lien_CLient`, nous aurons automatiquement une
modification du fichier `Client_Secret` (*et vice et versa*), car la modification s’effectuera physiquement sur le disque dur sur l’inode “*partagé*” par les deux fichiers.

### 2) Les liens symboliques

Le lien symbolique correspond à un pointeur vers une cible distante.

`ln -s [Fichier_lié_source] [Nom_pointeur]`

![vmware_w6qemglfrt.png](/uploads/linux_basics/vmware_w6qemglfrt.png){.align-center}
![vmware_iyxmjlajrv.png](/uploads/linux_basics/vmware_iyxmjlajrv.png){.align-center}

En affichant les éléments de notre répertoire, on retrouve bien notre lien.

![vmware_stv2qflthd.png](/uploads/linux_basics/vmware_stv2qflthd.png){.align-center}

Si vous avez fait un peu de programmation en C, nous retrouvons ici le concept de pointeur. Quand on appelle le fichier linux-test-lien-sym, il va automatiquement se diriger vers le fichier linux-test.

> **Remarque** : Le lien symbolique fait référence à un fichier dans un répertoire alors que le lien dur fait référence à un espace sur le disque dur.
{.is-warning}


> Les liens symboliques sont des fichiers de petite taille qui ont une existence propre sur le disque dur. Ces fichiers contiennent les références des fichiers sources auquels ils correspondent.

> Dans le cas d’un lien dur, la suppression de l’un des deux fichiers n’affectera pas l’autre.

> Dans le cas d’un lien symbolique, la suppression du fichier source entraînera un changement de comportement du fichier lien qui ne correspondra plus à un fichier valide et sera donc dit "broken".

Options utiles :

`ln -b` réalise une sauvegarde d’un fichier existant et dont nous aurions utilisé le nom avant de l’écraser.

`ln -i` demande à l’utilisateur s’il souhaite écraser le fichier qui a un lien sur le fichier source au cas ou celui-ci existerait déjà.

`ln -d` effectue des liens durs sur des répertoires.

## gzip (Compression/décompression archive .gz)

Pour compresser un fichier : `gzip [Nom_fichier]`
Pour décompresser un fichier : `gzip -d [Nom_fichier].gz`

![vmware_bcp6thzcoo.png](/uploads/linux_basics/vmware_bcp6thzcoo.png){.align-center}
![vmware_1atvt75occ.png](/uploads/linux_basics/vmware_1atvt75occ.png){.align-center}

## tar (Archivage et compression)

La commande `tar` permet d’archiver ou de désarchiver des répertoires et des fichiers de facon optimale.

Une des commandes dont vous aurez certainement le plus besoin est :

> Décompression et désarchivage : `tar xvzf [nom_du_fichier].tar.gz`
{.is-success}

![vmware_gz9gxici4k.png](/uploads/linux_basics/vmware_gz9gxici4k.png){.align-center}

Le format `.tar.gz` indique que le fichier est en réalité une archive (*.tar*), c’est-à dire que le fichier contient en réalité plusieurs fichiers, et qu’il est compressé (*.gz*). 

La commande précédente peut être ainsi comprise :

`x` (*extract*) permet d’extraire certains fichiers d’une archive (*lorsque l’on ne spécifie pas les noms des fichiers que l’on souhaite extraire de l’archive, tar les extrait tous*). 
`v` est le mode verbose pour obtenir plus de détails lors de l'exécution de la commande.
`z` décompacte l’archive. 
`f` extrait un fichier donné (*ici le fichier est `[nom_du_fichier].tar.gz`*).

Compression et archivage : `tar cvzf [nom_du_fichier].tar.gz`

![vmware_aen2ubjkga.png](/uploads/linux_basics/vmware_aen2ubjkga.png){.align-center}
![vmware_hx75p8awia.png](/uploads/linux_basics/vmware_hx75p8awia.png){.align-center}

...

En cours...
| Plugin | README |
| ------ | ------ |
.
.
.
.
.
```sh
$ npm install --production
$ NODE_ENV=production node app
```
